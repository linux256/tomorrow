\newpage

## DEPLOY CONFIGURE AND MAINTAIN SYSTEMS
# 39. Start, stop and configure services ti automatically start at boot

---

### I. SYSTEMCTL UNIT FILES

`man systemd.unit`

> Páginas man de configuracion de las unit files 

`systemctl -t help`

> Muestras las unit disponibles: `service  target  -  socket   path  -
mount   automount  -  device   swap  -  timer    slice  scope`

*Rutas de mayor a menor prioridad para los unit files* 

* **`1º)      /run/systemd/system`**  *unit files generados automáticamente*
* **`2º)      /etc/systemd/system`**  *custom unit files, v.g. systemctl edit*
* **`3º)  /usr/lib/systemd/system`**  *default unit files, de paquetes RPM*

`systemctl list-unit-files -t service`  
`systemctl list-unit-files *.service`

> Enumera todos los unit files y su estado (habilitado, deshabilitado, estático)
> de tipo `service`

`systemctl edit  atd.service`

> Edita el unit file del servicio `atd`

### II. SERVICE UNITS

`man systemd.service`

> manpages de las unit de servicios, con la sintáxis

> `[Unit]             # Describen la unidad y sus dependencias`   
> `Description=...`  
> `Before=...         # Este servicio se debe iniciar antes de ...`  
> `After=...          # Este servicio se debe iniciar despues de ...`  
> `...`  
> `[Service]          # Como iniciar, parar y consultar estado`  
> `Type=...           # forking (daemons); oneshot, simple (comandos)`  
> `ExecStart=...      # comandos a ejecutar para iniciar el servicio`  
> `ExecStop=...       # comandos a ejecutar cuando se para el servicio`  
> `...`  
> `[Install]          # En que target iniciar el servicio`  
> `WantedBy=...       # Crea el` *`want`* ` para el servicio`  
> `...`

### III. MOUNT UNITS

`man systemd.mount`

> manpages de las unit de montaje, con la sintáxis

> `[Unit]`  
> `Description=...`  
> `Conflicts=...`  
> `...`  
> `[Mount]`  
> `What=...`   
> `Where=...`  
> `Type=...`  
> `Options=...`  
> `...`  
> `[Install]`  
> `WantedBy=...`  
> `...`

### IV. SOCKET UNITS

`man systemd.socket`

> manpages de las unit de socket, con la sintáxis

> `[Unit]`  
> `Description=...`  
> `Documentation=...`  
> `Wants=unit.service`  
> `...`  
> `[Socket]`  
> `ListenStream=...      # TCP`   
> `ListenDatagram=...    # UDP`  
> `...`  
> `[Install]`  
> `WantedBy=...`  
> `...`

### V. TARGET UNITS

`man systemd.target`

> manpages de las unit de target, cuya sintáxis solo tiene el bloque unit

> `[Unit]`  
> `Description=...`  
> `Documentation=...`  
> `Requires=basic.target `  
> `Conflicts=...`   
> `After=mio.target            # Se iniciará despues de mio.target`  
> `AllowIsolate=               # Se puede transicionar a este target`  
> `...`  

**Requires.** Expresa una dependencia mas rígida que un *want*. Si la unidad
se activa, las unidades que se indiquen tras Requires=... se activarán también.
Si una de estas unidades requeridas se para o se reinicia, la unit que las 
requiere se parará o se reiniciará

**Conflicts.** Expresa una dependecia de requisito inverso. La unit donde se 
defini Conflicts=... será detenida si se inician las unidades en conflicto y
viceversa: si las unidades en conflicto se inician, esta unit se detendrá.

**Wants.** Expresan una dependencia débil. Las unidades que se quieren (los
*wants*), serán iniciadas si la unit es iniciada. No obstante si un *want* no
se inicia, la unit no se ve afectada. Esta es la forma recomendada de encadenar
las dependencias de un servicio con otro. Para implementar esto, cada `target`
tiene un subdirectorio con sus *wants* que son enlaces simbólicos a los
servicios que se quieren iniciar. Cuando un servicio se habilita, se crea su
sección `[Install]` y se genera el enlace simbólico en el subdirectorio del
target

`/etc/systemd/system/multi-user.target.wants/nombre.service`

> Directorio de *wants* de `multi-user.target` con el *want* `nombre.service`
que es un enlace simbólico a `/usr/lib/systemd/system/nombre.service`

`systemctl enable nombre.service`

> Crea un *want* para nombre.service

`systemctl list-dependencies ejemplo.target`

> Muestra las unidades Requeridas y los *wants*  de `ejemplo.target`. Solo 
muestra las unidades cargadas en memoria, no analiza unidades no cargadas

`systemctl list-dependencies --reverse nombre.service`

> Realiza la búsqueda inversa: que units requieren o quieren a `nombre.service`


