\newpage

## UNDERSTAND AND USE ESSENTIAL TOOLS
# 07. Create and edit text files

---

### I. MOSTRAR CONTENIDO DE UN FICHERO DE TEXTO. ORDENACION.

`less -MiN -FX -S fichero`

> *pager* por defecto, empleado para mostrar páginas de `man`.
> Muestra contenido de fichero, (`-M`) con prompt largo, (`-i`) ignora MAY/min
> al buscar, (`-N`) número de línea, (`-F`) *finish* si el contenido cabe en
> pantalla, (`-X`) no borra el contenido en *exit*, (`-S`) *split* las líneas.
> Normalmente los comandos se pueden aplicar en tiempo de ejecución precedidos
> del comando "-", es decir se pueden poner/quitar números línea con "-N"

> Teclas utiles dentro de LESS:

* `g` , comienzo de fichero
* `G` , final de fichero
* `nG` , línea n
* `/word` , busca "word" hacia delante
* `n` , se mueve a siguiente ocurrencia de palabra hacia delante
* `?word` , busca "word" hacia atras
* `N` , se mueve a siguiente ocurrencia de palabra hacia atrás
* **`&word`** , *solo muestra líneas que contengan word*
* **`&!word`** , *solo muestra líneas que no contengan word*
* **`&!^#`** , *solo muestra líneas que no empiezan por # (no son comentarios!)*
* `SHIFT+f` , actualiza el contenido del fichero si varía (como `tail -f`)

`less --header=3,0,2 fichero`

> Muestra 3 líneas de cabecera fijas, descartando las dos primeras líneas del
> fichero. Muestra 0 columnas fijas. *Esta opción requiere version >600*

`cat -n -s f1 f2`

> Muestra concatenados los ficheros `f1` y `f2`, con (`-n`) números de línea y 
> suprimiendo (`-s`) segundas y sucesivas líneas en blanco

`paste f1 f2`

> Pega las líneas de `f1` y de `f2` una a una (como un `cat` vertical)

`tac file`

> Muestra fichero `file` con líneas en orden inverso, primero las últimas

`rev file`

> Muestra fichero `file` con cada línea al revés, del último al primer carácter

`sort file`

> Muestra líneas de `file` ordenadas según: 0,1,..9,a,A,b,B,c,C,...z,Z

`sort -n file`

> Ordena numéricamente las lines de `file`

`sort -nr file`

> Ordena numericamente de mayor a menor las líneas de `file`

`sort -k3n -t ',' file`

> Ordena `file` por el campo 3 numéricamente, separando campos por caracter ',' 

### II. MOSTRAR PARTES DE UN FICHERO DE TEXTO

`head -n file`

> Muestra las primeras n líneas de `file`

`tail -n file`

> Muestra últimas n líneas de `file`. Con `head -23 file | tail -1` solo la 23

`tail -f file`

> Muestra las últimas líneas de file (por defecto 10) y espera a las nuevas

`cut -d ':' -f 1 /etc/passwd`

> Muestra el *field* 1 del fichero `/etc/passwd` usando el delimitador `':'`

`cut -f2- file`

> Muestra desde el campo 2 hasta el final de cada línea de `file`

`cut -c 5 file ;  cut -c 5- file ;  cut -c 5-8 file ;  cut -c -8 file`

> Muestra caracter 5, desde el 5 (`5-`), del 5 al 8 (`5-8`), hasta el 8 (`-8`)

### III. LINEAS UNICAS

`sort -u file`

> Muestra solo líneas únicas de 'file' ordenado

`uniq file`

> Elimina líneas duplicadas adyacentes de `file`

`uniq -u file`

> Muestra solo las líneas de `file` que no tienen duplicado adyacente

`uniq -d file`

> Muestra solo las líneas de `file` que tienen duplicado adyacente

`cat -n file.txt | sort -uk2 | sort -n | cut -f2-`

`awk '!x[$0]++' file.txt`

> Muestra solo las líneas diferentes de `file.txt` sin reordenarlo. Usando `awk`
> se crea una entrada en el array asociativo `x` empleando la línea (`$0`) como
> clave. La primera vez se crea con valor nulo, por lo que su negación es `true`
> y se imprime; posteriormente se post-incrementa para que una proxima aparición
> de la misma línea ya tenga valor 1, su negación sea `false` y no se imprima.

### IV. MANIPULACIONES AVANZADAS. AWK Y SED

`tr '#' '$' < f1 > f2`

> Reemplaza el caracter `#` por caracter `$` en `f1` y guarda resultado en `f2`

`touch file`

> Actualiza la fecha de acceso y modificación de `file` y lo creo si no existe

`awk 'pattern  {action}'  file`

> Ejecuta una accion en cada línea que se ajuste al patrón, que puede ser una
ex.reg: `/regex/`

`awk 'NR==3 {print} file`

> Imprime la tercera línea de `file`

`awk '{print $11, $3}' file}`

> Imprime campos 11 y 3 separados por espacios de `file`

`awk '/marte/ {print}' file`

> Imprime todas las líneas de `file` que contengan la cadena `marte`

`awk '$2==7 {print $11}' file`

> Imprime el campo 11 de aquellas líneas cuyo campo 2 sea exactamente 7

`awk '$2>=7 && /firefox/ {print $11/1024}' file`

> Imprime el campo 11 dividido por 1024, cuando el campo 2 es mayor que 7 y la
> línea contiene la cadena `firefox`

`awk 'BEGIN {sum=0} /Byte/ {sum+=$4} END {printf("Size:%0.fKB\n",sum/1024)}' f1`

> Ejecuta el bloque `BEGIN {...}` al comienzo. Para cada línea ejecuta el bloque
> `/Byte/ {...}`. Al final del fichero ejecuta el bloque `END {...}`

`sed [options] 'comando' file`

> Forma general de `sed` que ejecuta comando sobre `file`

`sed -n '5,7p'  file`

`sed -n '5,+2p' file`

> Omite imprimir todas las líneas (`-n`) y solo imprime (`p`) las líneas 5,6 y 7

`sed -i 's/old/new/g' file`

> Sobreescribe el fichero de entrada (`-i`) y reemplaza (`s`) `old` por `new` en
> todas las líneas  (`g`) de `file`. El termino a reemplazar suele ser una BRE y
> el reemplazo puede ser en una ocurrencia específica (v.g. `2` en lugar de `g`)

`sed -i '2d;5,7d'  file`

> Reemplaza 'file'  eliminando las filas 2, 5, 6 y 7

`sed -i '/borrar/d' file`

> Elimina todas las líneas de `file` que contienen la cadena `borrar`

`for i in *.md; do sed -i '1 i\\--INICIO--' "$i"; done`

> Inserta en la línea 1 (`1 i\`) el texto `--INICIO--`, es decir al comienzo del
fichero, escapando backslash, en todos los ficheros (`"$i"`) con extensión `md`.
Con `'$ a\\\ntexto'` añade nueva línea al final de los ficheros.

### V. EL EDITOR DE TEXTO VI

`vi --version`

> Muestra version de VI y con que funcionalidades esta compilado. En particular
> si no incluye `extra_search` no resaltara las busquedas

`vi +7 fichero`

> Abre `fichero` en `vi` y se posiciona en la línea 7

***Comandos y teclas de interés***

* `i` inserta en la posición del cursor
* `a` inserta a la derecha del cursor
* `I` inserta al comienzo de la línea
* `A` inserta al final de la línea
* `o` abre línea a continuación de la línea actual
* `O` abre línea encima de la línea actual  
* `s`  elimina caracter actual y cambia a modo INSERT
* `S`  elimina linea actual y cambia a modo INSERT
* `C`  borra desde cursor al final de la línea y cambia a INSERT
* `cc` elimina linea actual y cambia a modo INSERT, como (`S`)
* `cw` change word, borra desde cursor al final de la palabra y cambia a INSERT
* `caw` change a word, borra palabra completa y cambia a INSERT
* `cG` borra desde la línea actual al final del fichero y cambia a INSERT
* `vG$c` selecciona desde cursor hasta final del fichero, borra y pasa a INSERT

>

* `dw` borra desde el cursor al final de la palabra
* `daw` delete a word, borra palabra donde esta el cursor
* `dd` borra línea
* `3dd` borra 3 líneas
* `d$` borra hasta final de la línea, no borra el salto de línea
* `D`  borra hasta final de la línea, no borra el salto de línea
* `dG` borra hasta final del fichero   
* `yy` copia línea completa
* `3yy` copia 3 líneas a buffer
* `y$` copia hasta el final de la línea
* `yG` copia hasta el final del fichero
* `p` pega el contenido borrado o copiado al buffer despues de la línea actual
* `P` pega el contenido encima de la línea actual
* `u` deshace la última acción
* `CTRL-r` repite última acción

>

* `:3` va a la línea 3
* `3G` va a la línea 3
* `gg` va al comienzo del fichero, como `1G`
* `G` va al final del fichero
* `^` va al comienzo de la línea, como `0`
* `$` va al final de la línea
* `zz` centra la visualización del texto para llevar la linea actual al centro

>

* `/text` busca "text" hacia adelante (`n` siguiente aparición, `N` anterior)
* `/\<word\>` busca la palabra "word" completa
* `?text` busca "text" hacia detrás (`n`, `N` avanzan en el sentido de busqueda)
* **`d/word`** borra hasta que encuentra "word" excluido
* **`d/word/e`** borra hasta que encuentra "word" incluido
* **`y/word`** copia hasta que encuentra "word" excluido
* **`y/word/e`** copia hasta que encuentra "word" incluido
* `:s/old/new/` reemplaza "old" por "new" en la línea
* `:s/old/new/g` cambia "old"<-> "new" todas las veces (`g`) en la línea
* `:%s/old/new/g` cambia "old"<->"new" todas las veces de todas (`%`) las líneas

>

* `:wq` guarda y sale
* `:w nombre` guarda buffer como "nombre" pero mantiene abierto fichero original
* `:sav nombre` guarda buffer como "nombre" y se cambia al fichero "nombre"
* `:e nombre` abre el fichero "nombre"

>

* `:set number` muestra numeros de línea (o `:set nu`)
* `:set nonumber` oculta numeros de línea (o `:set nonu`)
* `:set hls` activa highlight de todas las apariciones en búsquedas
* `:set nohls` solo se resalta la siguiente aparición, no todas
* `:nohl` oculta highlight actual
* `:set listchars=nbsp:.` establece "." para nbsp (ALT+255, C-k + spc + spc)
* `:set list` muestra caracteres no imprimibles, como nbsp 
* `:set backup` realiza backup del fichero (fichero acabado en ~)
* `:r! comando` ejecuta comando e inserta su salida en buffer

>

* `m a` fija la marca "a" en la posición actual
* ```a `` lleva el cursor justo a la marca "a". ```'`` regresa donde estaba
* `'a ` lleva el cursor al primer caracter no vacio de la línea de la marca "a"

>

* `*` selecciona las ocurrencias de la palabra actual
* `cgn TEXTO` cambia la ocurrencia por el texto que se introduzca
* `ESC` regresa a modo normal
* `n` avanza a la siguiente ocurrencia. `N` va a una ocurrencia anterior
* `.` operador repetir, cambia la seleccion por la palabra introducida (TEXTO)

>

* `CTRL-V` para acceder a modo VISUAL
* `jjjj` o down,down,down para marcar las líneas donde anteponer el `#`
* `I` para pasar a insertar al comienzo de la línea
* `#` para escribir el caracter que se quiere insertar
* `ESC` para aplicar el cambio a todas las líneas y salir del modo VISUAL

>

* `CTRL-N` propone terminos para autorellenar con palabras previamente escritas
* `SHIFT-K` ejecutado desde modo normal, muestra ayuda del termino elegido, si
es un comando de Linux, muestra su página man

### VI. BUFFER, VENTANAS y PESTAÑAS

*Una pestaña es una coleccion de ventanas. Una ventana muestra la vista de un
buffer. Un buffer es el contenido de un texto en memoria. Un buffer siempre se
mostrará en una ventana. Un buffer se puede mostrar en mas de una ventana, pero
lo normal es que diferentes ventanas muestren distintos buffers. Una pestaña
puede ser un entorno de trabajo (con varios buffers mostrados en ventanas),
separado visualmente de otro entorno.*


`vi fichero1 fichero2            # abre fichero1 y fichero2 en dos buffers`

* `:new` crea nuevo buffer
* `:bd` borra buffer actual
* `ls` muestra los buffers cargados (como `:files`)
* `b2` cambia al buffer 2
* `b!2` cambia al buffer 2 aunque haya cambios sin guardar en el buffer actual

`vi -o fichero1 fichero2  # abre fichero1 y fichero2 en 2 ventanas horizontales`

`vi -O fichero1 fichero2  # abre fichero1 y fichero2 en 2 ventanas verticales`

* `:vsp file` divide ventana verticalmente y carga `file` si se especifica
* `:sp file` divide ventana horizontalmente y carga `file` si se especifica
* `CTRL-w v` divide ventane verticalmente en dos (una a la izqda y otra a dcha)
* `CTRL-w s` divide ventana horizontalmente (una arriba y una abajo)
* `CTRL-w c` cierra ventana actual
* `:n` mueve a ventana siguiente
* `:N` mueve a ventana anterior
* `CTRL-w up|down|left|right` cambia a otra ventana
* `CTRL-w <|>` cambia el ancho de la ventana actual
* `CTRL-w +|-` cambia el alto de la ventana actual

`vi -p fichero1 fichero2`

> Abre `fichero1` y `fichero2` en dos pestañas de `vi`

* `:tabnew` crea una nueva pestaña
* `:tabclose` cierra pestaña actual
* `:tabs` lista las pestañas actuales
* `:tab3` cambia a la pestaña 3
* `:tabn` cambia a la próxima pestaña
* `:tabp` cambia a la pestaña anterior

---

*Referencias*

* https://gist.github.com/hansrajdas/6520d74ac3251552e66a76f2f32b4bdd


