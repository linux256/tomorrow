\newpage

## MANAGE SECURITY
# 54. Configure key-based authentication for SSH

---

### I. GENERAR PAREJA DE CLAVES EN EL CLIENTE LOCAL: SSH-KEYGEN

`~/.ssh/id_rsa`

> Nombre por defecto de la clave privada

`~/.ssh/id_rsa.pub`

> Nombre por defecto de la clave pública

**`ssh-keygen [opciones]`**

> Genera pareja de claves privada-pública con las siguientes opciones,

* `-f output_keyfile`  establece el nombre de los ficheros con las claves
* `-C 'comentario'`  fija comentario al crear las claves
* `-c -C 'nuevo comentario'` cambia comentario de las claves
* `-m` crea la clave en formato PEM antiguo
* `-p` cambia la passphrase de la clave
* `-t rsa` fija el tipo de clave generada (dsa, ecdsa, ed25519, rsa,...)
* `-R 192.168.0.22` borra entradas del host `192.168.0.22`  del fichero
`~/.ssh/known_hosts`

### II. COPIAR CLAVE AL SERVIDOR REMOTO: SSH-COPY-ID

`ssh-copy-id  user@remoteserver`

> Copia la clave pública mas reciente de `~/.ssh/*.pub` que no esté ya en el
destino, a la carpeta `~/.ssh` del usuario `user` en `remoteserver`

`ssh-copy-id  -f  -i nombrefile  -p 2022  student@192.168.0.20`

> Copia en el servidor remoto forzando (`-f`) la escritura aunque ya exista, la
clave pública con el nombre (`-i`) `nombrefile.pub`, conectándose al servidor
remoto en el puerto (`-p`) 2022, y la guarda en la carpeta home del usuario
`student` en el fichero `~/.ssh/authorized_keys`. Si se añade el parámetro
(`-n`) se muestra lo que se haría pero no se ejecuta nada.

`~/.ssh/authorized_keys`

> Fichero en la carpeta home del usuario en el host remoto donde se añaden las
claves públicas empleadas por el usuario para conectarse a este servidor, y que
habitualmente serán una por cada cliente de conexión, de manera que se pueda
borrar selectivamente impidiendo que pueda conectarse empleando determinadas
parejas de claves (clientes/dispositivos)

### III. USAR PAREJA DE CLAVES EN EL CLIENTE: SSH

`ssh -i nombre  user@hostremoto`

> Emplea la clave privada `nombre` para conectarse a `hostremoto`

`man ssh_config`

> Ayuda sobre el fichero de configuración del cliente SSH

`~/.ssh/config`

> Fichero de configuración personalizado del cliente SSH para establecer las
opciones de conexión, que pueden incluir parametros personalizados para cada
HOST remoto en distintas secciones:

> `Host              192.168.0.22`  
> `IdentityFile      clave1`

`/etc/ssh/ssh_config`

> Fichero de configuración general del cliente SSH que permite establecer
opciones de conexión distintas para cada servidor, como por ejemplo la clave
a emplear, los comandos de inicio, etc.

### IV. RECORDAR PASSPHRASE DE CLAVE PRIVADA

`ssh-agent  /bin/bash`

> Inicia ssh-agent y ejecuta un shell `/bin/bash` como un subproceso. El agente
termina cuando lo hace el subproceso

`ssh-add nombreclave`

> Añade la clave pública `nombreclave` al agente, solicitando la contraseña la
primera vez y recordándola mientras el agente esté en ejecución.

>

### V. CONFIGURACIONES HABITUALES DE SEGURIDAD EN HOST: SSHD_CONFIG

`man sshd_config`

> Ayuda sobre los parámetros de configuración del servicio `sshd`

>

**1.- Deshabilitar el login de root**

Una forma es NO establecer una contraseña al usuario `root` como sucede por
defecto al instalar RHEL, lo que impide iniciar sesión TTY o SSH. Pero se puede
tener login shell de `root`:

> `sudo -i` : login shell RUID=EUID=0. Se debe pertenecer a `wheel`. **No
necesita passw de root**  
> `su - ` : login shell RUID=n,EUID=0. Sí necesita tener y conocer passw de root

Para configurar el acceso de `root` por SSH se emplea en `/etc/ssh/ssd_config`
el parámetro,

> `[PermitRootLogin   no]` : no permite ningún acceso de `root` por SSH, es la
opción recomendada.

> `[PermitRootLogin   prohibit-password]` : valor por defecto, impide el inicio
por SSH a `root` usando una contraseña. Solo podría iniciar con clave pública

> `[PermitRootLogin   forced-commands-only]` : permite sólo la ejecución de
comandos por SSH y empleando la autenticación con clave pública

**2.- Cambiar puerto de sshd**

Se recomienda iniciar dos sesiones de ssh antes de hacer un cambio, ya que un
restart exitoso no cerrará las sesiones activas.

* Cambiar/añadir tantas líneas como puertos se quieran habilitar:

> `[Port   22  ]` : habilita el puerto 22, por defecto  
> `[Port   2022]` : al añadir esta línea, SSH funciona TAMBIÉN en el puerto 2022

* Dar contexto `ssh_port_t` a los puertos añadidos:

> `semanage port  -a  -t ssh_port_t  -p tcp 2022` : añade label a pto 2022/tcp  
> `semanage port  -m ...` : modifica label del puerto  
> `semanage port  -l` : lista los puertos y sus label

* Habilitar el puerto en el firewall

> `firewall-cmd --add-port=2022/tcp --permanent && firewall-cmd --reload`

**3.- Limitar que usuarios pueden acceder, registrar fallos y deshabilitar el
uso de contraseñas**

Se puede limitar que usuarios inician por SSH y registrar accesos exitosos y
fallidos,

* Limitar usuarios que acceden:

> `[AllowUsers   usr1,usr2,usr3]` : solo estos usuarios pueden conectar por SSH  

* Registrar accesos:

> `[MaxAuthTries   6]` : a partir del fallo 4 incluido se registra, usando la
facility `AUTHPRIV` en el fichero `/var/log/secure`

> `/var/log/secure` fichero donde se registran los intentos fallidos

> `/var/log/auth.log` fichero donde se registran los intentos exitosos

* Deshabilitar el empleo de contraseñas y el empleo de contraseñas vacías

> `[PasswordAuthentication   no]` : no se puede iniciar SSH empleando password

> `[PermitEmptyPasswords     no]` : no permitir emplear password vacías


**4.- Verificar IP del hostname del cliente usando DNS**

Retrasa el inicio SSH (es causa habitual de retraso al iniciar la conexión),

* `[UseDNS  yes]` : emplea DNS; *deshabilitar si el cliente tarda en conectar*

**5.- Máximo número de conexiones desde la misma IP de origen**

* `[MaxSessions   10]` : establece no más de 10 clientes SSH conectados desde la
misma IP

**6.- Desconectar clientes que permanecen inactivos un tiempo determinado**

* `[ClientAliveInternal  30]` : manda al cliente 1 paq tras 30s de inactividad
* `[ClientAliveCountMax  10]` : manda un máximo de 10 paquetes de inactividad
* `[TCPKeepAlive  yes]` : libera una conexión si está inactiva según condiciones
anteriores, evitando que en caso de desconexión permanezcan sesiones *ghost*

Desde el cliente se puede lograr algo similar en `/etc/ssh/ssh_config` o en
`~/.ssh/config` con los parámetros,

* `[ServerAliveInternal  30]` : periodo de 30s para mandar paquetes
* `[ServerAliveCountMax  10]` : número de paquetes *keepalive* enviados


**7.- Limitar el número de procesos por usuario**

Para evitar el colapso de un sistema por una *fork bomb*,

`:(){ :|:& };:`

> `:() {   }` define la función `:` sin argumentos

> ` :|:` la función se carga en memoria y envía su salida a sí misma, para lo
que se debe cargar a su vez en memoria

> ` & ` se ejecuta en background de manera que los procesos hijos no reciben
`kill` aunque se envíe la señal a sus padres.

> `;:` tras definir la funcioń, la ejecuta

`man limits.conf`

> Ayuda sobre los límites definibles para el módulo `pam_limits`

`/etc/security/limits.conf`

> Fichero donde establecer los límites por defecto (`soft`) y máximo (`hard`)
del numero de recursos que un usuario puede ejecutar. Para evitar un agotamiento
por *fork* el recurso a limitar es `nproc`:

> `user1     hard   nproc   100`  limita a `user1` un maximo de 100 procesos  
> `@gr1      hard   nproc   200`  limita miembros del grupo `gr1` a 100 proc  
> `1:1000    hard   nproc   100`  limita los UID del 1 al 1000 a 100 procesos  
> `1:        hard   nproc   100`  limita todos salvo root a 100 procesos  
> `*         hard   nproc  1000`  límite por defecto de 1000 procesos

`ulimit`

> Gestiona los límites de recursos que puede emplear el shell actual, según:

* `-a` muestra todos los límites del shell
* `-Su` muestra límite soft de número de procesos
* `-Hu` muestra límite hard de número de procesos

`ulimit -Su 100 && ulimit -Hu 100`

> Limita a 100 el número de procesos del usuario. El límite soft no puede ser
superior al límite hard, por lo que primero se reduce el límite soft y luego se
reduce el límite hard. Si ahora se ejecuta una *fork bomb* el número de procesos
del usuario será de 100. Iniciando sesion como `root` se matan:

> `# ps aux | grep student | wc -l` : cuenta el número de procesos de `student`  
> `# killall -s SIGKILL -u student` : mata todos los procesos de `student`


