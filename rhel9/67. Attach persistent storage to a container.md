\newpage

## MANAGE CONTAINERS
# 67. Storage persistent storage to a container

---

### I. BIND-MOUNT CUANDO EL USUARIO DEL CONTENEDOR ES ROOT [EX200]

*El almacenamiento persistente se logra haciendo un bind-mount de un directorio
del host que aparentará ser un dispositivo de bloques para el contenedor. Para
esto se deben cumplir tres condiciones:*

1. *El directorio en el host debe ser escribible por el usuario que ejecuta el
contenedor*

2. *El directorio en el host debe tener el contexto `container_file_t`*

3. *Para poder aplicar el contexto automáticamente al ejecutar el contenedor,
el usuario que ejecuta el contenedor debe ser propietario del directorio en el
host*

>
```
mkdir /home/student/datastore          # se es propietario y se puede escribir
podman run -it  -v /home/student/datastore:/data:Z  ubi9`
```

> Ejecuta un contenedor basado en la imagen `ubi9`, se conecta a *TTY*, y monta
el directorio `/home/student/datastore/` en el directorio `/data` del contenedor
y asigna automáticamente el contexto `container_file_t` al directorio del host
y al directorio en el contenedor.  
El emplear `Z` para el *bind-mount* indica que el contexto aplicado será para
uso privado: el storage no será compartido por múltiples contenedores (para eso
se debe emplear `z`).  
El mismo proceso se puede seguir asignando el contexto de manera manual:

> ```
mkdir /home/student/data2
sudo semanage fcontext -a -t container_file_t "/home/student/data2(/.*)?"
restorecon -Rv /home/student/data2
podman run -it v /home/student/data2:/data2  ubi9
```

`podman inspect nameCont | grep -niA 10 Mounts`

> Inspecciona las propiedades del contenedor `nameCont` en busca de la sección
`Mounts` donde están definidos los *bindmount* que se hayan creado

*El inconveniente de este método es que el propietario del dispositivo dentro
del contenedor es `root` y otros usuarios no podrán escribir en el. Este método
solo sirve si dentro del contenedor los procesos corren con el usuario `root`
lo cual no es recomendable por seguridad (dentro del contenedor tampoco se
recomienda trabajar con `root`). Hay que poder asignar un propietario específico
dentro del contenedor distinto de `root`*

### II. BIND-MOUNT CUANDO EL USUARIO DEL CONTENEDOR NO ES ROOT [EX200]

`podman inspect mysql | grep -i UID`  
`podman exec  mysqlCont grep mysql /etc/passwd`

> Dos alternativas para averiguar el UID con que se ejecutan los servicios o 
procesos dentro del contenedor. Este UID es el que habrá que asignar como nuevo
propietario del directorio compartido del host en el espacio de usuario creado
para  ejecutar el contenedor


`podman unshare chown 999:999 /home/student/datastore`

> Ejecuta *en el espacio de usuario* (`unshare`), el cambio de propietario del
directorio del host que se montará, para asignar UID=999 y GID=999. Dentro
del contenedor estos son los propietarios que se verán. Desde el host los
propietarios que se verán son 10000+999-1 = 10998 (en el host ejecutar
`cat /etc/subuid` y en el contenedor ejecutar **`cat /proc/self/uid_map`**)

`podman run -d -e MYSQL_ROOT_PASSWORD=root       \`  
`.             -e MYSQL_ALLOW_EMPTY_PASSWORD=yes \`  
`.             -e MYSQL_RANDOM_ROOT_PASSWORD=no  \`  
`.             -v /home/student/datastore:/var/lib/mysql:Z  mysql`

> Ejecuta un contenedor de `mysql` con las variables de entorno y montando la
ruta para la base de datos, estableciendo el contexto `container_file_t` de
modo automático

---

*Referencias,*

* https://wiki.dominic-ricottone.com/Podman/BindMounts

> *The root user within a container effectively runs as the host user that
created the container. All non-root users within the container effectively use
some other mapped UID that does not exist on the host system. If running podman
as a user and using bind mounts, it is necessary to carefully consider the
ownership of those files and directories.*

> *It is possible to calculate the UID that effectively will be used, based on
the subuid range and the relevant UID within the container. For example, if the
host user's range starts at 165536 and the relevant container UID is 999, then
the files and directories could be chown(1)ed to 166534 (165536 - 1 + 999). But
this is not the recommended approach. Instead try:*

> `podman unshare chown 999:999 -R path/to/mount`



* https://unix.stackexchange.com/questions/651198/podman-volume-mounts-
when-to-use-the-z-or-z-suffix

> *Labeling systems like SELinux require that proper labels are placed on volume
content mounted into a container. Without a label, the security system might
prevent the processes running inside the container from using the content. By
default, Podman does not change the labels set by the OS. To change a label in
the container context, you can add either of two suffixes :z or :Z to the volume
mount. These suffixes tell Podman to relabel file objects on the shared volumes.
The z option tells Podman that two containers share the volume content. As a
result, Podman labels the content with a shared content label. Shared volume
labels allow all containers to read/write content. The Z option tells Podman to
label the content with a private unshared label.*


* https://www.tutorialworks.com/podman-rootless-volumes/

> *User namespaces are a Linux feature that allow you to wrap and isolate a
process, so that it appears to be running under its own, different set of
security identities – such as user IDs and group IDs. In Podman’s user
namespace, there is a new set of user IDs and group IDs, which are separate
from the UIDs and GIDs on your host.*

> *You can see the actual mappings by viewing the file /proc/self/uid_map inside
your container.*

> *All rootless containers must be run in the same user namespace. If they are
not, some things (like sharing the network namespace from another container)
would be impossible.*

> *By using the same user namespace, your containers can share resources with
each other, without needing to ask for root privileges. It uses this user
namespace to mount filesystems, or run a container which accesses more than one
user ID (UID) or group ID (GID). This mapping is fine for most situations,
except when the container needs to be able to share something with the host,
like a volume.*

> *But - here’s the important thing: When the container runs, any volumes which
are shared with it, will appear inside the user namespace as owned by root/root.
When the container runs, any volumes which are shared with it, will appear
inside the user namespace as owned by root/root. Because the mapping will map
your UID on the host (e.g. 1000) as root (0) in the container.*

> *This means that if you’re running your container process as a non-root user,
it won’t be able to write to that directory.So how do we change the owner of the 
directory in the container, so the user can write to it?*

> *Since Podman uses user namespaces to make the magic of different user IDs
and group IDs work, it would be helpful if we had a way of accessing this same
user namespace, when we need to fix or investigate something. This is where
`podman unshare` comes in.*

> *It uses the unshare command, part of the Linux kernel. unshare is one of the 
commands that actually makes user namespaces possible, and therefore containers.
unshare - run program in new namespaces. The unshare command creates new
namespaces and then executes the specified program.*

> *When you use podman unshare, you’re effectively jumping out of your normal 
namespace, and into the Podman user namespace. It’s like executing the unshare
command as the Podman process. So you can execute a command in the same user
namespace, such as changing file permissions, or browsing your filesystem, if
you need to.*


* https://docs.solace.com/Software-Broker/Container-Tasks/
rootless-containers.htm


