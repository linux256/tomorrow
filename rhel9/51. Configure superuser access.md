\newpage

## MANAGE USERS AND GROUPS
# 51. Configure superuser access

---

### I. CONOCER USUARIO EN CURSO

`id  usuario`

> Muestra identidad del usuario y grupos a los que pertenece (1º el primario)

`whoami`

> Muestra nombre de usuario del EUID o *effective user ID*

`ps -p $$ -o pid,euid,ruid,suid,egid,rgid,sgid,cmd`

> Muestra PID del shell actual y los identificadores de identidad:

* `euid` effective user id, identidad empleada por el proceso para chequear
permiso de acceso a ficheros y para establecer el propietario de los ficheros
que crea el proceso
* `ruid` real user id, identidad del propietario del proceso y afecta a los
permisos para enviar señales
* `suid` saved user id, almacena el EUID al que regresa el proceso cuando
termine
* `egid` effective group id, identidad del grupo para permisos y establecer
grupo propietario
* `rgid` real group id, identidad del grupo propietario del proceso
* `sgid` saved grop id, identidad del EGID almacenada a la que regresar


### II. SWITCH USER: SU (*SWITCH USER OR SUBSTITUTE USER*)

`su  user`

> Inicia *non-login shell* como `user`, para lo cual pide su contraseña de
`user` salvo que se ejecute como `root`

`su - user`

> Inicia un *loginshell* como `user` pidiendo contraseña de `user`

**`su -`**

> Inicia *loginshell* como `root` pidiendo contraseña de `root`.  
> **Modo recomendado para hacer loginshell `root` conociendo contraseña**

### III. EJECUTAR COMO ROOT: SUDO (*SUPERUSER DO OR SUBSTITUTE USER DO*)

`usermod -aG wheel user`

> Agrega `user` al grupo `wheel` que puede realizar sudo

`visudo`

> Edita el fichero de configuración de `sudoers`

`man sudoers`

> Ayuda sobre el fichero de `sudoers`

`/etc/sudoers`  
`/etc/sudoers.d/`

> Fichero de configuración de usuarios que pueden realizar `sudo` de acuerdo
a sintaxis, `who   where=(as_whom) what`. Admite *dropins* en subdirectorio.
Ejemplos de líneas,

> `Defaults  timestamp_timeout=240   # la contraseña se mantiene 240 segundos`  
> `Defaults  timestamp_timeout=-1    # se mantiene hasta siguiente reinicio`  
> `...`  
> `%wheel ALL=(ALL)ALL   # miembros de wheel, desde cualquier equipo, todo`  
> `u2     ALL=/usr/bin/passwd,/usr/bin/vi   # u2 puede ejecutar passwd y vi`  
> `u2     ALL=/usr/bin/passwd,!/usr/bin/passwd root # no cambiar pass de root`  
> `u2     ALL=  TIMEOUT=15m /usr/bin/bash   # limita a 15min sesion sudo -i`  

`sudo -l`

> Lista privilegios del usuario actual

`sudo sh -c "comando1|comando2"`

> Ejecuta como `root` dos comandos dirigiendo la salida de uno a otro, pidiendo
la contraseña del usuario actual para validad como sudoer

`echo "contraseñaDeUser" | sudo -S comando`

> Ejecuta como `root` un comando, tomando la contraseña de `user` desde STDIN
donde es dirigida por el pipe desde la salida de `echo`. *Esto es similar al uso
en `echo "contraseña" | passwd --stdin usuario` para cambiar la contraseña del
usuario leyéndola desde STDIN*.

`sudo -i  -u user2`

> Inicia loginshell como el usuario `user` sin pedir contraseña de `user2`, pero
pide la contraseña del usuario que hace `sudo` para validarse como `sudoer`

**`sudo -i`**

> Inicia loginshell de `root` pidiendo contraseña del usuario que hace `sudo` para validarse como `sudoer`  
> **Modo recomendado para hacer loginshell `root` NO conociendo contraseña**

`pkexec  comando`

> Ejecuta comando de manera privilegiada, como `sudo comando`, pero validando
desde interfaz gráfica (PolicyKit)

>

---

*Referencias,*

**TIPOS DE SHELL -- INFORMACION ADICIONAL**

**1. Tipos de shell**

*shell*: interfaz entre el usuario y el kernel del sistema operativo. 

*interactive shell*: el usuario proporciona la entrada escribiendo comandos en
el terminal empleando el teclado, y el shell proporciona salida mostrando sus
mensajes en pantalla. Este es el caso más habitual y en el que centrarse para
distinguir interactive login de interactive non-login

*non-interactive shell*: el usuario no proporciona comandos por teclado y los
mensajes de salida normalmente se escriben en ficheros de log

*login shell*: el usuario accede al sistema proporcionando sus credenciales como
pueden ser su nombre de usuario y su contraseña. El proceso de login indica al
shell que se comporte como *login shell* anteponiéndolo un "-" es decir
ejecutando `-bash` en lugar de `bash`. De esta manera al ejecutar `ps -f` se
puede distinguir un *login shell*. Téngase en cuenta que al iniciar en GUI
no se obtiene un *login shell*

*non-login shell*: el usuario no proporciona sus credenciales.

Las cuatro combinaciones son (especial atención a las dos primeras),

* **interactive login shell**: se ejecuta cuando el usuario accede al sistema y 
hace login en consola o mediante SSH recibiendo un entorno personalizado.

* **interactive non-login shell**: cualquier otro shell abierto por el usuario
tras acceder al sistema, normalmente empleado para ejecutar tareas de
 mantenimiento o administrativas (variables, cambiar la hora, copiar ficheros,
escribir scripts, etc)

* non-interactive login shells: de uso raro y poco práctico. Por ejemplo forzar
la ejecución de un script con `/bin/bash  --login  script_name`  o dirigir la
salida de un comando a STDIN de una conexion SSH:  `comando | ssh user@server`

* non-interactive non-login shells: no hay ni interacción ni login en nombre
del usuario por lo que no se lee ningun fichero de inicio. Se emplean para la
ejecucion de scripts automatizados como en las tareas de cron

**2. Como distinguir que tipo de shell tengo**

`echo $0`

* ` bash, /bin/bash`:  estoy en INTERACTIVE NON-LOGIN SHELL
* `-bash ,  -su`:  estoy en INTERACTIVE LOGIN SHELL
* ` script_name`:  estoy en NON-INTERACTIVE NON-LOGIN SHELL


**3. Ficheros de inicio de los shell**

Los ficheros globales van en `/etc` y los personalizados en `~`. Por el orden
de ejecución, los locales tienen precedencia sobre los globales. Cuando
se busca mas de un fichero, solo se ejecuta el primero encontrado.

INTERACTIVE LOGIN SHELL
 
> Global

> > `/etc/profile `   
> > `/etc/profile.d/*`

> Local  

> > `~/.bash_profile` (especifico de bash)   
> > `~/.bash_login`  (especifico de bash, si no existe el anterior)   
> > `~/.profile`  (no especifico de bash, si no existen los anteriores)  
> > `~/.bash_logout` (especifico de bash para el *logout*)   

INTERACTIVE NON-LOGIN SHELL

> Global

> > `/etc/bash.bashrc`

> Local

> > `~/.bashrc` (habitual para `history`, alias y funciones)

**4. Como iniciar shells**

NON INTERACTIVE SHELL

> `bash script_name`  
> `bash -c comando`  

INTERACTIVE NON-LOGIN SHELL

> `bash -i script_name    # se necesita alguna variable de shell interactivo..`  
> `bash -i -c comando     # idem`  
> `bash`  
> `bash --norc            # no emplea ningun fichero de inicio bashrc`  
> `bash --rcfile <file>   # cambia el fichero de inicio en lugar de bashrc`  

> `su user                # inicia interactive non-login shell como user`  
> `su root                # inicia interactive non-login shell como root`  
> `su                     # inicia interactive non-login shell como root`  

> `sudo su user           # ejecutando temporalmente el comando su`  
> `sudo su root           # ""`  
> `sudo su                # ""`  
> `sudo -u user -s        # ejecutando temporalmente un shell (-s)`  
> `sudo -u root -s        # ""`  
> `sudo -s                # ""`  

INTERACTIVE LOGIN SHELL

> `bash -l`  
> `bash --login`  
> `bash --login  --noprofile  # no emplea fichero de inicio de login profile`  

> `su -  user             # interactive login shell como user`  
> `su -l user             # interactive login shell como user`  
> `su --login user        # interactive login shell como user`  
> `su -  root             # interactive login shell como root`  
> **`su -                   # interactive login shell como root`**  

> `sudo su -  user        # ejecutando temporalmente comando su`  
> `sudo su -l user        # ""`  
> `sudo su --login user   # ""`  
> `sudo su -  root        # ""`  
> `sudo su -              # ""`  
> **`sudo -i                # ejecutando temporalmente un login shell (-i)`**  
> `sudo -i comando        # ejecuta comando y regresa al usuario original`  


