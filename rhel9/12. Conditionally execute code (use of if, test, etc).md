\newpage

## CREATE SIMPLE SHELL SCRIPTS
# 12. Conditionally execute code (use of if, test, [...], etc.)

---

### I. TEST

`test expr`

`[ expr ]`

> *Built-in* command que chequea la expresión `expr`. Chequeos típicos son que
> exista un fichero o una comparación numérica

* `test -f $1` chequea que existe un fichero con el nombre del 1er argumento
* `[ -f $1 ]` chequea que existe un fichero con el nombre de $1
* `[ -d $1 ]` chequea que el primer argumento sea un directorio
* `[ -e $1 ]` chequea que el primer argumento sea un fichero o un directorio
* `[ -L $1 ]` chequea que el primer argumento sea un enlace simbólico

>

* `[ -z $1 ]` chequea que longitud del primer argumento sea cero (i.e no existe)
* `[ -n $1 ]` chequea que longitud de $1 no sea cero, es decir que exista
* `[ $1 = $2 ]` chequea que la cadena 1 sea igual a la cadena 2
* `[ $1 == $2 ]` chequea que la cadena 1 sea igual a la cadena 2
* `[ $1 != $2 ]` cheque que las cadenas sean distintas

>

* `[ $a -eq 1 ]` chequea que a=1
* `[ $b -ne 2 ]` chequea que b!=2
* `[ $c -lt 3 ]` chequea que c<3
* `[ $d -le 4 ]` chequea que d<=4
* `[ $e -gt 5 ]` chequea que e>5
* `[ $f -ge 6 ]` chequea que f>=6

`[ -z $1 ] && echo "no argument" || echo "argumento 1: $1"`

> En BASH se ejecuta de izquierda a derecha y **no hay precedencia de && sobre
> ||**.  
> Si `[ -z $1 ]` es cierto (si termina con exit code=0), el operador `&&`
> necesita evaluar su parte derecha, que es `echo "no argument"`. Como `echo`
> termina con 0 (true), el operador `||` no necesita ejecutar su parte derecha.
>   
> Si `[ -z $1 ]` es falso (termina con exit code!=0), el operador `&&` ya no
> necesita ejecutar su parte derecha. Como la parte izquierda de `||` es falsa
> (el exit code que se entrega a `||` es !=0) el operador `||` necesita evaluar
> su parte derecha.
> 
> Se logra un IF en una línea: *`condición && acción_true || accion_false`*

### II. TEST AVANZADO Y EXPRESIONES ARITMETICAS

`[[ expr ]]`

> *Bash expansion* que aumenta posibilidades de comparación.  
>  Por ejemplo: `[[ a = a && b = b ]]` es `true`  
>  Sin embargo: ` [ a = a && b = b ] ` da error  
>  Por ejemplo: `[[ hola = ho* ]]` es `true`  
>  Sin embargo: ` [ hola = ho* ] ` depende de que exista un fichero `hola` ya
>  que el shell substituye `ho*` por `hola`. BASH no entiende BRE en scripts y
>  lo que realiza es *filename expansion* o *globbing*

`(( expresion_aritmetica ))`

> Se evalua la expresión aritmética y si el resultado es >0, se considera TRUE
> por lo que exit code=0  
> Por ejemplo: `(( 1+4 )) && echo "true" || echo "false"` escribe `true`

### III. SENTENCIA CONDICIONAL IF

Una vez se cumple una condición, no se evaluan mas y se abandona el bloque
*(if ... then ... else ... fi)*

>

> ```
> if   condicion1
> then
>      bloque1
> elif condicion2
> then 
>      bloque2
> else
>      bloquesinohaycoincidencia
> fi
> ```

>

### IV. SENTENCIA CONDICIONAL CASE

Una vez se cumple un caso, no se evaluan mas y se abandona el bloque
*(case ... in valor1) ...;; valor2) ...;; `*`) ...;; esac)*

>

> ```
> case "$1"  in
>      azul)
>             echo "cielo";;
>      verde|Verde|VERDE)
>             echo "bosque";;
>      *)
>           echo "tierra";;
> esac
> ```



---

*Referencias*

* https://tldp.org/LDP/abs/html/globbingref.html


