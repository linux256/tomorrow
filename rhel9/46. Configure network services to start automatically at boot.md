\newpage

## MANAGE BASIC NETWORKING
# 46. Configure network services to start automatically at boot

---

### I. ENABLE, DISABLE, MASK, UNMASK

`systemctl enable servicio`

> Habilita `servicio` creando un symlink en el directorio `.wants` del target
especficado en la sección `[Install]` del servicio, es decir en la ruta
completa: `/etc/systemd/system/wantedby.target.wants/`

> Tras habilitar el servicio, la configuracion de Systemd se recarga, de manera
similar a `daemon-reload` para tener en cuenta la configuración con carácter
inmediato, pero esto no inicia el servicio.

> Intentar habilitar un servicio `masked` produce un error porque no es posible.

`systemctl enable --now servicio`

> Habilita el servicio y lo inicia inmediatamente.

`systemctl disable servicio`  

> Deshabilita un servicio, eliminando el symlink y recargando configuración de
systemd.

`systemctl disable --now servicio`

> Deshabilita un servicio y lo detiene inmediatamente.

`systemctl mask servicio`

> Enmascara un servicio impidiendo que pueda iniciarse, para lo cual cre un
enlace simbólico del servicio así: `/etc/systemd/system/servicio.service -> `
`/dev/null`

> El servicio no se detiene.

`systemctl mask --now servicio`

> Enmascara un servicio, y lo detiene inmediatamente

`systemctl mask --runtime servicio`

> Enmascara un servicio temporalmente, hasta el siguiente reinicio, creando para
ello el enlace simbólico: `/run/systemd/system/servicio.service -> /dev/null`

`systemctl unmask servicio`

> Permite que el sistema se inicie borrando su enlace simbólico en `/etc/...`

### II. DEPENDENCIAS DE UN SERVICIO

`systemctl list-dependencies servicio`

> Lista las units requeridas y wanted por `servicio`, es decir las units que
estén referenciadas en sus clausulas `Requires=`, `Requisite=` y `Wants=` de
la sección `[Unit]` (ver `man systemd.unit`).  
*Enumera que unidades se iniciarán junto a `servicio`, si no lo están ya*

`systemctl list-dependencies --reverse servicio`

> Lista para que units `servicio` es una dependencia, es decir en que *unit files*
aparece `servicio` como `Requisite`, `Requires` o `Wants`.  
*Enumera que units iniciarán `servicio`, si no lo está ya*

`systemctl list-dependencies --before servicio`

> Enumera el orden establecido para iniciar `servicio` antes que otros servcios,
es decir que enumera las unit referidas en la clausula `Before=` de la sección
`[Unit]` de servicio.  
*Cuando dos servicios 1 y 2 se inician y 1 incluye una clausula `Before=2`, el
servicio 1 se iniciará antes del 2. Cuando ambos servicios se detienen, el orden
es inverso y 2 se detendrá antes de 1. Cuando se ordena apagar uno e iniciar el
otro, siempre se realiza primero la detención (sea el que sea) y posteriormente
el inicio. Si no hay relacion de dependencia entre 1 y 2, y ambos se inician (se
detienen), la operación se realiza en paralelo*

`systemctl list-dependencies --after servicio`

> Enumera después de que servicios se iniciará `servicio` cuando se inician
conjuntamente

**Resumen clausulas dependencia**

```
[Unit]
  Requisite= .. # si estas unidades no están ya cargadas, la Unit fallará
  Requires= ... # estas unidades se cargarán también; si una se para, la Unit tb
  Wants= ...... # estas unidades se cargarán también; si una falla la Unit no
  Before= ..... # Unit se iniciará antes de estas unidades
  After= ...... # Unit se iniciará despues de estas unidades
```

### III. SERVICE UNIT FILE

**`systemctl show servicio`**

> Muestra propiedades de un servicio

**`systemctl cat  servicio`**

> Lista el contenido en vigor del unit file `servicio.service`, es decir el de
la ruta de mas prioridad: 1º `/run/..` , 2º `/etc/..` , 3º `/usr/lib..`

**`systemctl edit mio.service`**

> Edita *drop-in snippet* para modificar el comportamiento de la unit en:  
`/etc/systemd/system/mio.service.d/override.conf`

> Si el servicio no existe, puede crearse un fichero `.service`  usando los
parámetros `--force --full`. Posteriormnente, podrá añadirse el *drop-in* si
se quiere como a un servicio previamente existente

> Emplea la variable de sistema `SYSTEMD_EDITOR` o en su defecto `EDITOR`

`systemctl reload servicio`

> Recarga el fichero de configuración del servicio, **NO el unit file**. Por
ejemplo `systemctl reload httpd` recargará `httpd.conf`, no recargará el unit
file `httpd.service`

`systemctl daemon-reload`

> Recarga la configuracion de *systemd manager*, desencadenando la ejecución
de generadores (v.g. `/run/...mount` desde `/etc/fstab`), recargando **todos**
los unit files y recreando el arbol completo de dependencias.


