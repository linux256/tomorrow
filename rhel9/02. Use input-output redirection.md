\newpage

## UNDERSTAND AND USE ESSENTIAL TOOLS
# 02. Use input-output redirection (>, >>, 1, 2>, etc)

---

### I. STDIN, STDOUT, STDERR

*Cuando bash se inicia, por defecto abre 3 file descriptors (0,1,2) que apuntan
al terminal empleado, por ejemplo /dev/tty0. Se pueden abrir y cerrar mas file
descriptors (de 0 a 255) y se pueden copiar. Cuando se copian no se copia el
contenido, sino que se copia el dispositivo apuntado. En un file descriptor no
se puede regresar a una posicion anterior (rewind), solo se avanza. La
redireccion se puede realizar a device files (/dev/sda, /dev/console, /dev/tty,
/dev/null)*

`file_descriptorREDIRECCIONfichero`

> sintáxis general para redirigir (entrada <, salida >, añadir >>) o conectar 
> flujos, streams o file descriptors, a ficheros. Redirige flujos o ficheros.

`0<file`

> reemplaza file descriptor 0, STDIN, conectado normalmente a teclado, con file
> El 0 puede omitirse, reduciendose a `< file`

`1>file`

> redirige file descriptor 1, STDOUT, conectado normalmente monitor, a file
> El 1 puede omitirse, reduciendose a `> file`

`1>>file`

> redirige STDOUT añadiéndo su contenido a file

`2>file`

> redirige file descriptor 2, STDERR, conectado normalmente monitor, a file

`2>>file`

> redirige STDERR añadiendo su contenido a file

`2>&1`

> redirige file descriptor 2 a file descriptor 1. Hace que file descriptor 2
> (no su contenido) sea una copia de file descriptor 1 (no su contenido) 
>
> ejemplo de uso: `comando > f.txt 2>&1` redirige comando, y su posible
> salida de error a f.txt
 
`&>file`

`>&file`

> redirige STDERR y STDOUT a file. Abreviatura de `>file 2>&1`, que es distinto
> a `2>&1 >file`

### II. REDIRECCION AVANZADA

`comando <<<$var`

`comando <<<"$var"`

> redireccion "here-string" donde el contenido de `$var` pasa como `STDIN` a
> comando. Ejemplo: `grep "abc" <<<$var`, busca "abc" en el contenido de `var` 
> y no da errores de fichero/dir. no existente

```
comando <<MARK
entrada1
entrada2
...
MARK
```

> redireccion "here-doc" para entrada multilinea hasta el finalizador MARK. Un
> ejemplo de uso habitual es `cat > file.txt <<EOF` que facilita crear un
> fichero de texto sencillo introduciendo multiples lineas hasta escribir "EOF"

`exec 1>file`

> redirige STDOUT de manera permanente, para el shell en curso, a file

`exec 2>file`

> redirige STDERR de manera permanente, para el shell en curso, a file

`exec 3>file`

> redirige file descriptor 3 a file de manera permanente, pudiendo añadirle
> contenido hasta no cerrar el file descriptor
>
> ejemplo: `date >&3` escribira la fecha y hora al fichero file

`exec 3>&-`

> apunta file descriptor 3 a file descriptor '-' que en bash significa cerrar


`ls -l /proc/$$/fd`

> enumera los file descriptors abiertos, para el shell actual ($$ =el pid bash)

```
echo "12345678" > ejemplo
exec 4<> ejemplo
read -n 3 var <4&
read -n 3 var <4&
date >&4
exec 4>&-
cat ejemplo
```

> abre el fichero `ejemplo` para lectura y escritura, posicionándose al comienzo
> lee los primeros tres caracteres en la variable `var`, quedando el flujo en el
> caracter cuarto; vuelve a leer 3 caracteres en la variable `var` y el flujo
> queda en la posicion 6; en esa posición escribe la fecha y hora actual,
> quedando el flujo apuntando al final del fichero. `var` contiene "456" y
> `file` contiene "123456Sat Apr 12 10:39:23" 

```
mkfifo fichero_comandos    #ejecutado en shell 1
exec < fichero_comandos    #ejecutado en shell 1
...
exec 3> fichero_comandos   #ejecutado en shell 2
echo "date" >&3            #ejecutado en shell 2
...
exec 3>&-                  #ejecutado en shell 2
```

> reemplaza bash en shell 1, por los comandos leidos de "fichero_comandos" que
> es un fichero de tipo fifo, al que en shell 2 se le asigna el file descriptor
> 3 para escribir en los comandos que, de esta manera, se ejecutan en shell 1

### III. PIPE y TEE

`com1 | com2`

> opera entre comandos, dirige salida STDOUT de com1 a entrada STDIN de com2.
> Seria practicamente equivalente a `com1 > temp && com2 < temp`.
> En una linea multi-comando creada con `|` cada comando se ejecuta en un 
> subshell diferente, por lo que no hay visibilidad en las variables. Esto es
> causa habitual de funcionamiento imprevisto, v.g. en `echo 1 | read var` ya
> que var solo se conoce en el subshell que ejecuta `read var`

`com1 | tee fic.txt | com2`

> dirige la salida de com1 a STDIN de `tee`, que lee su STDIN y lo escribe en
> "fic.txt" y lo entrega a STDOUT, que a su vez se dirige a STDIN de com2. En
> resumen, la salida de com1 se registra en fic.txt y se pasa a com2

---

*Referencias*

* https://catonmat.net/bash-one-liners-explained-part-three


